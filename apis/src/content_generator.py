
import os
import re
creds_path = "src/CREDS.py"
assert os.path.isfile(creds_path), "\n\nsrc.CREDS is not present in the folder\n Ask Ashad for the file\n\n"

from src.CREDS import GOOGLE_GEMINI_API_KEY

if not GOOGLE_GEMINI_API_KEY or GOOGLE_GEMINI_API_KEY == "YOUR_API_KEY_HERE":
    raise ValueError("Please set the GOOGLE_GEMINI_API_KEY in src.CREDS.py")

# os.environ["GOOGLE_API_KEY"] = GOOGLE_GEMINI_API_KEY

import random
import logging
from typing import List, Tuple, Dict
import google.generativeai as genai
from IPython.display import Markdown
from src.logger import Logger, log_time
from src.emotion_analyzer import EmotionAnalyzer


class ContentGenerator:
    """
    A class to generate content based on a prompt using Google Gemini AI.
    """
    def __init__(self, api_key: str = GOOGLE_GEMINI_API_KEY):
        """
        Initialize the ContentGenerator with the API key.

        Args:
            api_key (str): The API key for Google Gemini AI.
        """
        genai.configure(api_key=api_key)
        self.logger = Logger("langchain_model", see_time=True)
        self.score_logger = Logger("score", see_time=True, console_log=True)
        self.model = genai.GenerativeModel("gemini-pro")
        self.emotion_analyzer = EmotionAnalyzer()
        self.emotions = ['admiration', 'amusement', 'anger', 'annoyance', 'approval', 'caring', 'confusion', 'curiosity', 'desire', 'disappointment', 'disapproval', 'disgust', 'embarrassment', 'excitement', 'fear', 'gratitude', 'grief', 'joy', 'love', 'nervousness', 'optimism', 'pride', 'realization', 'relief', 'remorse', 'sadness', 'surprise']
        self.positive_emotions = ['admiration', 'amusement', 'approval', 'caring', 'curiosity', 'excitement', 'gratitude', 'joy', 'love', 'optimism', 'pride', 'realization', 'relief', 'surprise']
        self.negative_emotions = ['anger', 'annoyance', 'confusion', 'desire', 'disappointment', 'disapproval', 'disgust', 'embarrassment', 'fear', 'grief', 'nervousness', 'remorse', 'sadness']
        
    def clean_question(self, question: str) -> str:
        """
        Clean the question text by removing any unwanted characters.

        Args:
            question (str): The question text.

        Returns:
            str: Cleaned question text
        """
        cleaned_ques = re.sub(r'\"[^\w\s]\"', '', question)
        return cleaned_ques
    
    def generate_emotion(self) -> str:
        """
        Analyze a job description and infer an emotion.

        Args:
            job_description (str): The job description text.

        Returns:
            str: An inferred emotion from the list.
        """
        emotion = random.choice(self.emotions)
        self.logger.log_message(f"Inferred emotion: {emotion}", level=logging.DEBUG)
        return emotion

    def respond_to_query(self, emotion: str, job_desc: str) -> str:
        """
        Respond to a query based on the inferred emotion.

        Args:
            emotion (str): The inferred emotion.
            query (str): The query about the emotion.

        Returns:
            str: A response generated by the model.
        """
        prompt = f"Based on the emotion '{emotion}', what behavioral question would you ask related to this job?\n\nJob Description:\n{job_desc}\n\n"
        response = self.model.generate_content(prompt)
        self.logger.log_message(f"Response to query: {response.text}", level=logging.DEBUG)
        return response.text
    
    def interview(self, job_desc: str) -> Tuple[str, float]:
        """
        Generate an interview question based on the inferred emotion.

        Args:
            emotion (str): The inferred emotion.
            job_desc (str): The job description text.

        Returns:
            str: An interview question related to the emotion.
        """        
        total_score = 0.0
        current_score = 0.0
        for i, emotion in enumerate(self.emotions):
            question = self.respond_to_query(emotion, job_desc)
            question = self.clean_question(question)
            user_answer = input(f"Answer the question: {question}\n")
            self.logger.log_message(f"Question for emotion '{emotion}': {question}\nAnswer: {user_answer}", level=logging.DEBUG)
            if user_answer.lower() == "no":
                break
            score = self.emotion_analyzer.analyze_response_emotion(emotion, user_answer)
            if emotion in self.positive_emotions:
                if score >= 0.5:  # Positive response to positive emotion
                    current_score = score * 100.0  # Good score
                else:  # Negative response to positive emotion
                    current_score = score * -50.0  # Bad score
            elif emotion in self.negative_emotions:
                if score >= 0.5:  # Positive response to negative emotion
                    current_score = score * -100.0  # Bad score
                else:  # Negative response to negative emotion
                    current_score = score * 50.0  # Good score
            else:  # Neutral emotion
                current_score = score * 75.0  # Neutral score
            current_score = score * 100.0 
            total_score += current_score / (i + 1)
            self.score_logger.log_message(f"Score for emotion '{emotion}': {current_score:.2f}%")
            self.score_logger.log_message(f"Total score: {total_score:.2f}%")
           
        print(f"Total score: {total_score:.2f}%")
        self.score_logger.log_message(f"Total score: {total_score:.2f}%")
        return total_score
    
    def interview_question(self, job_desc: str, question_index: int) -> Tuple[str, str]:
        """
        Generate an interview question based on the inferred emotion at the specified index.

        Args:
            job_desc (str): The job description text.
            question_index (int): The index of the question to generate.

        Returns:
            str: The interview question related to the emotion at the specified index.
        """
        if question_index < 0 or question_index >= len(self.emotions):
            return "No more questions."

        emotion = self.emotions[question_index]
        prompt = f"Based on the emotion '{emotion}', what behavioral question would you ask related to this job?\n\nJob Description:\n{job_desc}\n\n"
        question = self.model.generate_content(prompt).text
        cleaned_question = self.clean_question(question)
        return emotion, cleaned_question
    
    def score_answer(self, emotion: str, answer: str):
        """
        Score the answer based on the inferred emotion.

        Args:
            emotion (str): The inferred emotion.
            answer (str): The user's answer to the question.

        Returns:
            float: The score for the answer.
        """
        score = self.emotion_analyzer.analyze_response_emotion(emotion, answer)
        print(score)
        if emotion in self.positive_emotions:
            if score >= 0.5:  # Positive response to positive emotion
                current_score = score * 100.0  # Good score
            else:  # Negative response to positive emotion
                current_score = score * -50.0  # Bad score
        elif emotion in self.negative_emotions:
            if score >= 0.5:  # Positive response to negative emotion
                current_score = score * -100.0  # Bad score
            else:  # Negative response to negative emotion
                current_score = score * 50.0  # Good score
        else:  # Neutral emotion
            current_score = score * 75.0  # Neutral score
        # current_score = score * 100.0 
        self.score_logger.log_message(f"Score for emotion '{emotion}': {current_score:.2f}%")
        print(current_score)
        return current_score
    
if __name__ == "__main__":
    content_generator = ContentGenerator()
    emotion = content_generator.generate_emotion()
    job_desc = """
    **Position Title:** Software Engineer

**Description:**
Seeking a Software Engineer to develop high-quality software solutions in collaboration with cross-functional teams. Responsibilities include designing, coding, testing, and debugging software applications. 

**Qualifications:**
- Bachelor's degree in Computer Science or related field
- Proven experience in software development
- Proficiency in programming languages like Java, Python, or JavaScript
- Familiarity with web development frameworks and/or mobile app development is a plus
- Strong problem-solving and communication skills

**Benefits:**
- Competitive salary
- Health, dental, and vision insurance
- Flexible work schedule
- Opportunities for professional development

**How to Apply:**
Submit resume and cover letter to [Contact Information].
"""
    content_generator.interview_question(job_desc)
